console.log("üöÄ Inicializando MediaPipe HandLandmarker...");

// --- VARIABLES GLOBALES ---
const video = document.getElementById("webcam");
const canvasElement = document.getElementById("output_canvas");

// Comprobaci√≥n segura para canvasElement
let canvasCtx = null;
if (canvasElement) {
    canvasCtx = canvasElement.getContext("2d");
} else {
    console.error("‚ùå Error: No se encontr√≥ el elemento canvas con id 'output_canvas'");
}

const gestureStatus = document.getElementById("gesture-status");
const connectionStatus = document.getElementById("connection-status");



let videoDevices = [];
let currentDeviceIndex = 0;
let currentStream = null;
let isFrontCamera = true;



let handLandmarker = null;
let webcamRunning = false;
let lastGestureData = null;
let lastGestureType = "Ninguno";
let lastVideoTime = -1;
let socket = null;
let drawingUtils = null;
let isRoomJoined = false;
let isLocked = false;
let lockCooldown = 0;
const LOCK_COOLDOWN_FRAMES = 40;

let fistHoldCounter = 0; // Contador de frames que llevamos con 2 pu√±os
const LOCK_HOLD_FRAMES_REQUIRED = 15; // 3 segundos (60 frames @ 20fps)

let currentTarget = 'lienzo';

let targetLienzoButton;
let targetSlidesButton;

let rightHandState = { lastX: -1, lastY: -1, cooldown: 0, fistLastX: -1, lastState: 'open' };
let leftHandState = { lastX: -1, lastY: -1, cooldown: 0, fistLastX: -1, lastState: 'open' };
const SWIPE_THRESHOLD = 0.07;
const COOLDOWN_FRAMES = 5;
const FIST_MOVE_THRESHOLD = 0.01; // Sensibilidad m√≠nima para detectar movimiento del pu√±o


// --- CARGAR DESDE OBJETO GLOBAL ---
// Comprobaci√≥n segura de que las librer√≠as existen
if (!window.HandLandmarker || !window.FilesetResolver || !window.DrawingUtils) {
    console.error("‚ùå Error: Librer√≠a MediaPipe Tasks Vision no cargada. ¬øFalta el <script> en el HTML?");
    alert("Error: Librer√≠a MediaPipe no cargada. Revisa la consola.");
    // Detener ejecuci√≥n si faltan librer√≠as
    throw new Error("MediaPipe library not loaded.");
}
const { HandLandmarker, FilesetResolver, DrawingUtils } = window;

// --- CONFIGURAR SOCKET.IO ---
if (typeof io !== 'undefined') {
    socket = io();
    socket.on("connect", () => {
        console.log(`‚úÖ Conectado al servidor con ID: ${socket.id}`);
        if (connectionStatus) connectionStatus.innerText = `üü¢ Conectado`;
        // Lo ponemos aqu√≠ para asegurarnos de que est√© activo ANTES de que intentemos unirnos.
        socket.on('room-joined-success', (roomCode) => {
            // Buscamos el elemento de nuevo por si acaso
            const roomStatus = document.getElementById('room-status');
            if(roomStatus) roomStatus.textContent = `‚úÖ Conectado a Sala ${roomCode}`;
            isRoomJoined = true; // <-- ¬°MUY IMPORTANTE!
            console.log(`Uni√≥n a sala ${roomCode} confirmada.`);
        });
    });
    socket.on("disconnect", () => {
        console.log("‚ùå Desconectado del servidor");
        if (connectionStatus) connectionStatus.innerText = "üî¥ Desconectado";
        isRoomJoined = false; // <-- Resetea al desconectar
    });
} else {
    console.error("‚ùå Error: Librer√≠a Socket.IO no cargada.");
    alert("Error: Librer√≠a Socket.IO no cargada. Revisa la consola.");
    throw new Error("Socket.IO library not loaded.");
}

// --- L√ìGICA PARA CAMBIAR DESTINO ---
function setTarget(target) {
    console.log(`üñ±Ô∏è setTarget llamado con: ${target}`);
    currentTarget = target;
    console.log(`üéØ Nuevo destino AHORA es: ${currentTarget}`);
    if (targetLienzoButton && targetSlidesButton) {
        targetLienzoButton.classList.toggle('active', target === 'lienzo');
        targetSlidesButton.classList.toggle('active', target === 'slides');
    }
}

// --- CONFIGURAR BOTONES ---
function setupTargetButtons() {
    // --- ¬°NUEVA L√ìGICA DE SALA! ---
    const roomInput = document.getElementById('room-code-input');
    const joinBtn = document.getElementById('join-room-btn');
    const roomStatus = document.getElementById('room-status');

    if (joinBtn && roomInput && roomStatus) {
        joinBtn.addEventListener('click', () => {
            const roomCode = roomInput.value.trim();
            if (roomCode.length === 5) { // Valida que sea de 5 d√≠gitos
                socket.emit('join-room', roomCode);
                roomStatus.textContent = `Uniendo a ${roomCode}...`;
            } else {
                roomStatus.textContent = "C√≥digo inv√°lido.";
            }
        });
    }
    
    socket.on('room-joined-success', (roomCode) => {
            // Buscamos el elemento de nuevo por si acaso
            const roomStatus = document.getElementById('room-status');
            if(roomStatus) roomStatus.textContent = `‚úÖ Conectado a Sala ${roomCode}`;
            isRoomJoined = true; 

            console.log(`[Cliente] ¬°Confirmaci√≥n RECIBIDA del servidor para sala ${roomCode}!`);

        });

    console.log("üõ†Ô∏è Configurando botones...");
    targetLienzoButton = document.getElementById('target-lienzo');
    targetSlidesButton = document.getElementById('target-slides');
    if (targetLienzoButton) {
        targetLienzoButton.addEventListener('click', () => {
            console.log("üñ±Ô∏è Click en Bot√≥n Lienzo");
            setTarget('lienzo');
        });
        console.log(" L- Listener a√±adido a Lienzo");
    } else {
        console.warn(" Bot√≥n Lienzo no encontrado");
    }
    if (targetSlidesButton) {
        targetSlidesButton.addEventListener('click', () => {
            console.log("üñ±Ô∏è Click en Bot√≥n Slides");
            setTarget('slides');
        });
        console.log(" S- Listener a√±adido a Slides");
    } else {
        console.warn(" Bot√≥n Slides no encontrado");
    }

    const switchCamButton = document.getElementById('switch-cam-btn');
    if (switchCamButton) {
        switchCamButton.addEventListener('click', () => {
            if (videoDevices.length < 2) {
                console.log("No hay otras c√°maras a las que cambiar.");
                return;
            }
            
            // L√≥gica de tu ar-main.js
            currentDeviceIndex = (currentDeviceIndex + 1) % videoDevices.length;
            isFrontCamera = !isFrontCamera;
            console.log("Cambiando a c√°mara:", videoDevices[currentDeviceIndex].label);
            
            // Resetea el estado para que se re-inicialice el predictWebcam
            //webcamRunning = false; 
            
            enableCam(); // Llama a la nueva funci√≥n
        });

        /* Oculta el bot√≥n si solo hay una c√°mara
       if (videoDevices.length < 1) {
            switchCamButton.style.display = 'none';
        }
            */
    } else {
        console.warn("Bot√≥n 'switch-cam-btn' no encontrado.");
    }

    try {
        screen.orientation.addEventListener("change", () => {
            console.log(`Nueva orientaci√≥n: ${screen.orientation.type}`);
            // Resetea y reinicia la c√°mara con las nuevas constraints
            webcamRunning = false; 
            enableCam();
        });
    } catch (e) {
        console.warn("API de Screen Orientation no soportada.", e);
    }


    setTarget(currentTarget); // Estado inicial
}

// --- INICIALIZAR MODELO ---
async function runDemo() {
    // Salir si canvasCtx no se pudo obtener
    if (!canvasCtx) {
        alert("Error cr√≠tico: No se pudo obtener el contexto del canvas.");
        return;
    }

    console.log("üöÄ Inicializando MediaPipe HandLandmarker...");
    try {
        const filesetResolver = await FilesetResolver.forVisionTasks(
            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
        );

        handLandmarker = await HandLandmarker.createFromOptions(filesetResolver, {
            baseOptions: {
                // ‚úÖ ¬°USA EL MODELO V2 COMPATIBLE!
                modelAssetPath:
                // "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/latest/hand_landmarker.task",
                // ‚ùå Comenta o borra el modelo v1
                // modelAssetPath:
                  "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                delegate: "GPU",
            },
            runningMode: "VIDEO",
            numHands: 2,
            minHandDetectionConfidence: 0.7,
            minHandPresenceConfidence: 0.7,
            minTrackingConfidence: 0.7,
        });

        drawingUtils = new DrawingUtils(canvasCtx);
        console.log("‚úÖ HandLandmarker cargado exitosamente");
        video.addEventListener("playing", onVideoPlaying);
        await getCameraDevices(); 
        enableCam();

    } catch (error) {
        console.error("‚ùå Error al inicializar MediaPipe:", error);
        alert("Error al cargar el modelo. Revisa la consola y recarga.");
    }
}

// --- ACTIVAR C√ÅMARA ---
async function enableCam() {

   if (videoDevices.length === 0) {
        console.error("No hay c√°maras para iniciar.");
        return;
    }
    
    // Detiene el stream anterior si existe
    if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
        //video.removeEventListener("playing", onVideoPlaying); // Limpia el listener
    }

    const deviceId = videoDevices[currentDeviceIndex].deviceId;
    const currentDevice = videoDevices[currentDeviceIndex];
    
    // --- L√ìGICA CORREGIDA ---
    // Esta funci√≥n ya no adivina. Solo reporta el estado global
    // que se decidi√≥ en getCameraDevices() o al presionar el bot√≥n.
    console.log(`Cambiando a c√°mara: ${currentDevice.label}. ¬øEs frontal? ${isFrontCamera}`);
    // --- FIN DE LA CORRECI√ìN ---

    let videoWidth = 640;
    let videoHeight = 480;

    const isPortrait = screen.orientation.type.includes("portrait");
    if (isMobile() && isPortrait) {
        console.log("M√≥vil en modo vertical detectado. Invirtiendo constraints a 480x640.");
        videoWidth = 480;
        videoHeight = 640;
    } else {
         console.log("Modo escritorio o paisaje. Usando constraints 640x480.");
    }

    const constraints = {
        video: {
            deviceId: { exact: deviceId },
            width: videoWidth,
            height: videoHeight
        }
    };
    
    try {
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        currentStream = stream;
        video.srcObject = stream;
       // video.addEventListener("playing", onVideoPlaying); 
        video.play();
    } catch (err) {
        console.error("Error al iniciar c√°mara:", err);
    }
}

function isMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}

function onVideoPlaying() {
    // Ajusta el tama√±o del canvas al nuevo stream de video
    if (canvasElement && video) {
        canvasElement.width = video.videoWidth;
        canvasElement.height = video.videoHeight;
    }
    
    // Esta l√≥gica estaba en tu antiguo listener "loadeddata"
    if (!webcamRunning) {
        webcamRunning = true;
        console.log("üì∑ Webcam iniciada. Empezando predicci√≥n...");
        predictWebcam();
    }
    
    // Aplica el efecto espejo si es necesario
    updateMirrorEffect();
}
function updateMirrorEffect() {
    // Usamos .classList para a√±adir/quitar la clase CSS que definiste
    if (isFrontCamera) {
        video.classList.add('mirrored');
        canvasElement.classList.add('mirrored');
    } else {
        video.classList.remove('mirrored');
        canvasElement.classList.remove('mirrored');
    }
}

async function getCameraDevices() {
    try {
        // Pide permiso primero
        await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
    } catch (e) {
        console.error("Permiso de c√°mara denegado:", e);
        alert("Necesitas dar permiso a la c√°mara para continuar.");
        return;
    }

    const devices = await navigator.mediaDevices.enumerateDevices();
    videoDevices = devices.filter(device => device.kind === 'videoinput');
    
    if (videoDevices.length === 0) {
        alert("No se encontraron c√°maras.");
    } else {
        console.log("C√°maras encontradas:", videoDevices);

        // Buscamos la c√°mara FRONTAL primero. Es m√°s seguro.
        const rearCamIndex = videoDevices.findIndex(device =>
            device.label.toLowerCase().includes('back') ||
            device.label.toLowerCase().includes('trasera')
        );

        if (rearCamIndex !== -1) {
            // Si la encontramos, la usamos y sabemos que ES TRASERA.
            console.log("C√°mara trasera encontrada, us√°ndola primero.");
            currentDeviceIndex = rearCamIndex;
            isFrontCamera = false;
        } else {
            // Si NO encontramos una trasera, asumimos que la default (0) es FRONTAL.
            console.log("No se encontr√≥ c√°mara trasera, usando la default (asumida frontal).");
            currentDeviceIndex = 0;
            isFrontCamera = true;
        }
    }
}

// --- DETECCI√ìN CONTINUA ---
let lastProcessedTime = 0;
const FRAME_INTERVAL = 1000 / 20; // Procesar ~20 FPS

async function predictWebcam() {
    if (!handLandmarker || !webcamRunning || !video || video.readyState < 2) {
        if (webcamRunning) requestAnimationFrame(predictWebcam);
        return
    };

    const now = performance.now();
    if (now - lastProcessedTime < FRAME_INTERVAL) {
        requestAnimationFrame(predictWebcam);
        return;
    }
    lastProcessedTime = now;

    if (lastVideoTime !== video.currentTime) {
        lastVideoTime = video.currentTime;
        try {
            const results = handLandmarker.detectForVideo(video, now);
            if (results && drawingUtils) {
                drawResults(results);
                processGestures(results); // Llamada √∫nica aqu√≠
            }
        } catch(error) {
            console.error("Error en detectForVideo:", error);
        }
    }

    if (webcamRunning) {
        requestAnimationFrame(predictWebcam);
    }
}

// --- DIBUJAR RESULTADOS ---
function drawResults(results) {
    if (!canvasCtx || !drawingUtils) return;
    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

    if (results.landmarks) {
        for (let i = 0; i < results.landmarks.length; i++) {
            const landmarks = results.landmarks[i];
            if (results.handedness && results.handedness[i] && results.handedness[i][0]) {
                const hand = results.handedness[i][0].categoryName;
                const color = hand === 'Right' ? '#00FF00' : '#FF00FF';
                drawingUtils.drawConnectors(landmarks, HandLandmarker.HAND_CONNECTIONS, { color: color, lineWidth: 3 });
                drawingUtils.drawLandmarks(landmarks, { color: '#FF0000', radius: 4 });
            } else {
                drawingUtils.drawConnectors(landmarks, HandLandmarker.HAND_CONNECTIONS, { color: '#CCCCCC', lineWidth: 3 });
                drawingUtils.drawLandmarks(landmarks, { color: '#FF0000', radius: 4 });
            }
        }
    }
    canvasCtx.restore();
}

// --- PROCESAR GESTOS ---
function processGestures(results) {
¬† ¬† if (!socket) return;

¬† ¬† let detectedGestureData = null;
¬† ¬† let currentGestureText = "üôå No se detectan manos...";
¬† ¬† let fistCount = 0;

¬† ¬† // --- 1. REDUCIR COOLDOWNS ---
¬† ¬† rightHandState.cooldown = Math.max(0, rightHandState.cooldown - 1);
¬† ¬† leftHandState.cooldown = Math.max(0, leftHandState.cooldown - 1);
¬† ¬† lockCooldown = Math.max(0, lockCooldown - 1);

¬† ¬† const handsDetected = results?.landmarks?.length > 0;

¬† ¬† // --- 2. PROCESAR SI HAY MANOS ---
¬† ¬† if (handsDetected) {
¬† ¬† ¬† ¬† currentGestureText = "üñêÔ∏è Mano detectada";

¬† ¬† ¬† ¬† // --- 3. CONTAR PU√ëOS ---
¬† ¬† ¬† ¬† // (Tu l√≥gica de FIST_CONFIDENCE_THRESHOLD es buena, pero no estaba en este c√≥digo)
¬† ¬† ¬† ¬† for (const landmarks of results.landmarks) {
¬† ¬† ¬† ¬† ¬† ¬† if (detectFistOrOpen(landmarks) === 'fist') fistCount++;
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† // --- 4. GESTO DE BLOQUEO (DOBLE PU√ëO) ---
¬† ¬† ¬† ¬† if (fistCount === 2 && lockCooldown === 0) {
            // Si tenemos 2 pu√±os, empezamos a contar
            fistHoldCounter++;

            // Calcular el progreso para mostrarlo en pantalla
            let chargePercent = Math.round((fistHoldCounter / LOCK_HOLD_FRAMES_REQUIRED) * 100);
            currentGestureText = `‚è≥ Bloqueando (${chargePercent}%)`;

            // ¬øLlegamos al tiempo requerido?
            if (fistHoldCounter >= LOCK_HOLD_FRAMES_REQUIRED) {
                isLocked = !isLocked;
                lockCooldown = LOCK_COOLDOWN_FRAMES; // Activar el cooldown de 2 seg
                currentGestureText = isLocked ? "üîí Bloqueado" : "üîì Desbloqueado";
                console.log(`Sistema ${currentGestureText} (¬°3 seg. completados!)`);
                const lockData = { type: 'system_lock', isLocked: isLocked };
                console.log(`üì° Enviando [gesture-data]:`, lockData);
                socket.emit('gesture-data', lockData);
                // Resetear todo para el pr√≥ximo gesto
                fistHoldCounter = 0;
                resetHandStates(); 
                lastGestureData = null;
                if (gestureStatus) gestureStatus.innerText = currentGestureText;
                lastGestureType = currentGestureText;
                return; // Salir del procesamiento de este frame
            }

        } else {
            // Si el gesto se rompe (menos de 2 pu√±os), reiniciamos el contador
            fistHoldCounter = 0;
        }
¬† ¬† ¬† ¬† // --- 5. SI EST√Å BLOQUEADO ---
¬† ¬† ¬† ¬† if (isLocked) {
¬† ¬† ¬† ¬† ¬† ¬† currentGestureText = "üîí Bloqueado";
¬† ¬† ¬† ¬† ¬† ¬† resetHandStates();
¬† ¬† ¬† ¬† } 

¬† ¬† ¬† ¬† // --- 6. PROCESAR GESTOS SI NO EST√Å BLOQUEADO ---
¬† ¬† ¬† ¬† else {
¬† ¬† ¬† ¬† ¬† ¬† for (let i = 0; i < results.landmarks.length; i++) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const landmarks = results.landmarks[i];


                if (!isHandPointingUp(landmarks)) {
                // Si la √∫ltima vez S√ç detectamos algo, resetea
                if (lastGestureData?.type !== 'open' && currentTarget === 'lienzo') {
                    // Env√≠a 'open' una vez para que el lienzo sepa que soltamos el gesto
                    socket.emit('gesture-data', { type: 'open' });
                    lastGestureData = { type: 'open' };
                }
                currentGestureText = "üñêÔ∏è Mano hacia abajo (ignorada)";
                resetHandStates();
                continue; // Salta al siguiente ciclo del bucle
            }


¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const handInfo = results.handedness[i]?.[0];

¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (!handInfo) continue;

¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const hand = handInfo.categoryName;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const handStateRef = (hand === 'Right') ? rightHandState : leftHandState;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† 
                // --- CAMBIO: Obtener estado actual y anterior ---
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const currentState = detectFistOrOpen(landmarks);
                const lastState = handStateRef.lastState;

¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (currentState === 'fist') {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // --- L√ìGICA LIENZO (INTACTA) ---
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (currentTarget === 'lienzo') {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const currentFistX = landmarks[9].x; 
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const lastX = handStateRef.fistLastX;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (lastX !== -1) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const deltaX = currentFistX - lastX;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (Math.abs(deltaX) > FIST_MOVE_THRESHOLD) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.log(`‚úä ${hand} DeltaX: ${deltaX.toFixed(4)}`);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† detectedGestureData = { type: 'fist_move', hand, deltaX };
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† currentGestureText = `‚úä Moviendo ${hand} (${deltaX > 0 ? '‚Üí' : '‚Üê'})`;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† handStateRef.fistLastX = currentFistX;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† handStateRef.fistLastX = -1; // Reset si no es lienzo
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† } 
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† else { 
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // --- Mano abierta (currentState === 'open') ---
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (handStateRef.fistLastX !== -1) handStateRef.fistLastX = -1;

¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // --- CAMBIO: L√ìGICA 'FIST-TO-OPEN' (para slides) ---
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (currentTarget === 'slides' && !detectedGestureData) {
                        // Si el estado anterior era 'fist' y el actual es 'open'
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (lastState === 'fist') {
                            detectedGestureData = { type: 'fist_to_open', hand: hand };
                            currentGestureText = `‚úã ¬°${hand} Abierta! (Slides)`;
                            
                            // --- ¬°LA SOLUCI√ìN! ---
                            // Actualiza el estado ANTES de salir del bucle
                            handStateRef.lastState = currentState; 
                            break; 
                        }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
                    // --- FIN DEL CAMBIO ---
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }

                // --- CAMBIO: Actualizar el estado de la mano para el pr√≥ximo frame ---
                handStateRef.lastState = currentState;

¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // (Se elimin√≥ la l√≥gica de 'detectSwipe' de aqu√≠)
¬† ¬† ¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† ¬† ¬† // --- Si no hay gesto, enviar 'open' (para lienzo) ---
¬† ¬† ¬† ¬† ¬† ¬† if (!detectedGestureData && currentTarget === 'lienzo') {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† detectedGestureData = { type: 'open' };
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† resetFistPositions();
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† }

¬† ¬† } 
¬† ¬† // --- 7. SIN MANOS DETECTADAS ---
¬† ¬† else {
¬† ¬† ¬† ¬† if (isLocked) {
¬† ¬† ¬† ¬† ¬† ¬† currentGestureText = "üîí Bloqueado (sin manos)";
¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† resetHandStates();
¬† ¬† }

¬† ¬† // --- 8. ENV√çO DE DATOS (MODIFICADO) --- 
¬† ¬† const dataChanged = JSON.stringify(detectedGestureData) !== JSON.stringify(lastGestureData);

¬† ¬† if (!isLocked && detectedGestureData ) {
        // --- CAMBIO: Actualizado para 'fist_to_open' ---
¬† ¬† ¬† ¬† const isSlideGesture = currentTarget === 'slides' && detectedGestureData.type === 'fist_to_open';
¬† ¬† ¬† ¬† const isLienzoGesture = currentTarget === 'lienzo' && ['fist_move', 'open'].includes(detectedGestureData.type);
        // --- FIN DEL CAMBIO ---

¬† ¬† ¬† ¬† if ((isSlideGesture || isLienzoGesture) && isRoomJoined) {
¬† ¬† ¬† ¬† ¬† ¬† console.log(`üì° Enviando [gesture-data] a ${currentTarget}:`, detectedGestureData);
¬† ¬† ¬† ¬† ¬† ¬† socket.emit('gesture-data', detectedGestureData);
¬† ¬† ¬† ¬† ¬† ¬† lastGestureData = { ...detectedGestureData };
¬† ¬† ¬† ¬† }
¬† ¬† }
¬† ¬† // Enviar 'open' impl√≠cito si antes hab√≠a otro gesto
¬† ¬† else if (!isLocked && !detectedGestureData && lastGestureData?.type !== 'open' && currentTarget === 'lienzo') {
¬† ¬† ¬† ¬† const openData = { type: 'open' };
¬† ¬† ¬† ¬† console.log(`üì° Enviando [gesture-data] a ${currentTarget}: { type: 'open' }`);
¬† ¬† ¬† ¬† socket.emit('gesture-data', openData);
¬† ¬† ¬† ¬† lastGestureData = openData;
¬† ¬† }
¬† ¬† // Reset si bloqueado
¬† ¬† else if (isLocked && lastGestureData) {
¬† ¬† ¬† ¬† lastGestureData = null;
¬† ¬† }

¬† ¬† // --- 9. ACTUALIZAR UI ---
¬† ¬† if (gestureStatus && currentGestureText !== lastGestureType) {
¬† ¬† ¬† ¬† gestureStatus.innerText = currentGestureText;
¬† ¬† ¬† ¬† lastGestureType = currentGestureText;
¬† ¬† }

¬† ¬† // --- Funciones internas auxiliares (sin cambios) ---
¬† ¬† function resetFistPositions() {
¬† ¬† ¬† ¬† rightHandState.fistLastX = -1;
¬† ¬† ¬† ¬† leftHandState.fistLastX = -1;
¬† ¬† }

¬† ¬† function resetHandStates() {
¬† ¬† ¬† ¬† resetFistPositions();
¬† ¬† ¬† ¬† rightHandState.lastX = -1;
¬† ¬† ¬† ¬† leftHandState.lastX = -1;
        // --- CAMBIO: Resetear tambi√©n lastState ---
        rightHandState.lastState = 'open';
        leftHandState.lastState = 'open';
¬† ¬† }
}


// --- FUNCI√ìN DETECTAR SWIPE ---
function detectSwipe(landmarks, hand) {
    let state = (hand === 'Right') ? rightHandState : leftHandState;
    if (!state) return null;
    if (state.cooldown > 0) return null;
    const handX = landmarks[9]?.x;
    if (handX === undefined) return null;
    let gesture = null;
    if (state.lastX !== -1) {
        const deltaX = handX - state.lastX;
        if (Math.abs(deltaX) > SWIPE_THRESHOLD) {
            gesture = { type: 'swipe', hand: hand, direction: deltaX > 0 ? 'right' : 'left' };
            state.cooldown = COOLDOWN_FRAMES;
            state.lastX = -1; state.lastY = -1;
        }
    }
    if (!gesture) { state.lastX = handX; }
    return gesture;
}


function detectFistOrOpen(landmarks) {
    // IDs de los landmarks de las puntas de los dedos
    const tipIds = [8, 12, 16, 20]; 
    const wristY = landmarks[0]?.y;
    // --- CAMBIO ---
    // IDs de los landmarks de los nudillos base (MCP)
    const mcpIds = [5, 9, 13, 17]; // <-- No usamos 6, 10, 14, 18

    if (!landmarks || landmarks.length === 0) {
        return 'open'; // No hay landmarks
    }

    let fingersClosed = 0;

    // Solo mostraremos esto de vez en cuando para no saturar la consola
    const shouldLog = Math.random() < 0.05; 
    if (shouldLog) console.log(`--- Depurando Pu√±o (V4) ---`);
    if (shouldLog) console.log(`Mu√±eca Y (WristY): ${wristY.toFixed(2)}`);


    // Comprobamos 4 dedos (√≠ndice, medio, anular, me√±ique)
    for (let i = 0; i < tipIds.length; i++) {
        const tipY = landmarks[tipIds[i]]?.y;
        
        // --- CAMBIO ---
        const mcpY = landmarks[mcpIds[i]]?.y; // <-- Usamos el nudillo base

        // Si no podemos leer los puntos, no contamos este dedo
        if (tipY === undefined || mcpY === undefined) {
            continue; 
        }


        if (shouldLog) {
            console.log(`Dedo ${i} (tip ${tipIds[i]}): tipY: ${tipY.toFixed(2)} -> ¬øCerrado (tipY > wristY)? ${tipY > wristY}`);
        }

        // L√≥gica: En un pu√±o, la punta del dedo (ej. 8) est√° M√ÅS ABAJO 
        // (valor Y m√°s alto) que el nudillo base (ej. 5).
        
        if (tipY > mcpY) { // <-- Comparamos tipY > mcpY
            fingersClosed++;
        }
    }
    if (shouldLog) {
            console.log(`Total Dedos Cerrados: ${fingersClosed} (requiere >= 2)`);
            console.log(`Resultado: ${fingersClosed >= 2 ? 'fist' : 'open'}`);
            console.log(`--------------------------`);
        }
    // --- CAMBIO ---
    // Si 2 o m√°s dedos est√°n cerrados, lo contamos como un pu√±o.
    // Esto es m√°s permisivo que antes (que ped√≠a 3).
    if (fingersClosed >= 2) {
        return 'fist';
    }
    
    return 'open';
}
function isHandPointingUp(landmarks) {
    if (!landmarks || landmarks.length === 0) return false;

    const wristY = landmarks[0]?.y; // Y de la Mu√±eca
    const tipY = landmarks[8]?.y;   // Y de la punta del dedo √≠ndice

    if (wristY === undefined || tipY === undefined) return false;

    // L√≥gica: La mano apunta hacia arriba si la punta del dedo (tipY)
    // est√° M√ÅS ALTA (valor Y m√°s peque√±o) que la mu√±eca (wristY).
    return tipY < wristY;
}

// --- ‚úÖ EJECUTAR TODO AL FINAL y SOLO UNA VEZ ---
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM Cargado. Ejecutando runDemo y setupTargetButtons.");
        runDemo();
        setupTargetButtons();
    });
} else {
    console.log("DOM ya estaba listo. Ejecutando runDemo y setupTargetButtons.");
    runDemo();
    setupTargetButtons();
}